name: Deploy to Azure Kubernetes Service

on:
  workflow_dispatch:
    inputs:
      backend_tag:
        description: "Backend image tag to deploy"
        required: true
        default: "latest"
      frontend_tag:
        description: "Frontend image tag to deploy"
        required: true
        default: "latest"
  push:
    branches: [main]
    paths:
      - "helm/**"

env:
  ACR_LOGIN_SERVER: ${{ vars.ACR_LOGIN_SERVER }}
  CLUSTER_NAME: ${{ vars.CLUSTER_NAME }}
  RESOURCE_GROUP: ${{ vars.RESOURCE_GROUP }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.CLUSTER_NAME }} \
            --overwrite-existing

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: "3.12.0"

      - name: Install cert-manager (if needed)
        run: |
          kubectl get crd clusterissuers.cert-manager.io || \
          helm repo add jetstack https://charts.jetstack.io && \
          helm repo update && \
          helm install cert-manager jetstack/cert-manager \
            --namespace cert-manager \
            --create-namespace \
            --version v1.13.3 \
            --set installCRDs=true
          # Wait for cert-manager to be ready
          kubectl rollout status deployment/cert-manager -n cert-manager --timeout=120s
          kubectl rollout status deployment/cert-manager-webhook -n cert-manager --timeout=120s
          kubectl rollout status deployment/cert-manager-cainjector -n cert-manager --timeout=120s

      - name: Install NGINX Ingress Controller (if needed)
        run: |
          kubectl get namespace ingress-nginx || \
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx && \
          helm repo update && \
          helm install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx \
            --create-namespace \
            --set controller.service.loadBalancerIP="${{ vars.INGRESS_IP }}"
          # Wait for ingress controller to be ready
          kubectl rollout status deployment/ingress-nginx-controller -n ingress-nginx --timeout=120s

      - name: Deploy Shared Resources
        run: |
          helm upgrade --install shared ./helm/shared \
            --set letsencrypt.email="${{ vars.LETSENCRYPT_EMAIL }}" \
            --set domain="${{ vars.DOMAIN }}"

      - name: Deploy Backend
        run: |
          # Parse MongoDB URI to extract host, port, and database
          MONGODB_URI="${{ secrets.MONGODB_URI }}"
          
          # Extract host (everything after @ and before / or ?)
          MONGO_HOST=$(echo "$MONGODB_URI" | sed -E 's/.*@([^/?]+).*/\1/')
          
          # For mongodb+srv, default port is 27017
          if echo "$MONGODB_URI" | grep -q "mongodb\+srv://"; then
            MONGO_PORT="27017"
          elif echo "$MONGODB_URI" | grep -q ":[0-9]\+/"; then
            MONGO_PORT=$(echo "$MONGODB_URI" | sed -E 's/.*:([0-9]+)\/.*/\1/')
          else
            MONGO_PORT="27017"
          fi
          
          # For mongodb+srv, the database name is not in the URI, use default
          if echo "$MONGODB_URI" | grep -q "mongodb\+srv://"; then
            MONGO_DB="campusconnect"
          else
            # Extract database name (everything after last / and before ?)
            MONGO_DB=$(echo "$MONGODB_URI" | sed -E 's/.*\/([^?]+).*/\1/')
          fi
          
          # Fallback values if parsing fails
          MONGO_HOST=${MONGO_HOST:-"localhost"}
          MONGO_PORT=${MONGO_PORT:-"27017"}
          MONGO_DB=${MONGO_DB:-"campusconnect"}
          
          echo "Parsed MongoDB config: Host=$MONGO_HOST, Port=$MONGO_PORT, DB=$MONGO_DB"
          
          helm upgrade --install backend ./helm/backend \
            --set image.repository="${{ env.ACR_LOGIN_SERVER }}/${{ vars.BACKEND_IMAGE_NAME }}" \
            --set image.tag="${{ github.event.inputs.backend_tag || 'latest' }}" \
            --set redis.host="${{ vars.REDIS_HOSTNAME }}" \
            --set redis.port="6380" \
            --set redis.ssl="true" \
            --set domain="${{ vars.DOMAIN }}" \
            --set mongodb.host="$MONGO_HOST" \
            --set mongodb.port="$MONGO_PORT" \
            --set mongodb.database="$MONGO_DB" \
            --set-string secrets.mongodb_uri="${{ secrets.MONGODB_URI }}" \
            --set-string secrets.redis_key="${{ secrets.AZURE_REDIS_KEY }}" \
            --set-string secrets.encryption_key="${{ secrets.ENCRYPTION_KEY }}" \
            --set-string secrets.session_secret="${{ secrets.SESSION_SECRET }}"

      - name: Deploy Frontend
        run: |
          helm upgrade --install frontend ./helm/frontend \
            --set image.repository="${{ env.ACR_LOGIN_SERVER }}/${{ vars.FRONTEND_IMAGE_NAME }}" \
            --set image.tag="${{ github.event.inputs.frontend_tag || 'latest' }}" \
            --set config.apiUrl="/api" \
            --set domain="${{ vars.DOMAIN }}"

      - name: Wait for pods to be ready
        run: |
          echo "Waiting for backend pods to be ready..."
          kubectl rollout status deployment/campus-connect-backend --timeout=300s
          
          echo "Waiting for frontend pods to be ready..."
          kubectl rollout status deployment/campus-connect-frontend --timeout=300s

      - name: Verify deployment health
        run: |
          echo "=== Checking pod status ==="
          kubectl get pods -l app=campus-connect-backend
          kubectl get pods -l app=campus-connect-frontend
          
          echo "=== Checking services ==="
          kubectl get services -l app=campus-connect-backend
          kubectl get services -l app=campus-connect-frontend
          
          echo "=== Checking ingress ==="
          kubectl get ingress campus-connect-ingress
          
          echo "=== Verifying pod health ==="
          # Check that all pods are Running and Ready
          BACKEND_PODS=$(kubectl get pods -l app=campus-connect-backend --no-headers | wc -l)
          BACKEND_READY=$(kubectl get pods -l app=campus-connect-backend --no-headers | grep "Running" | wc -l)
          
          FRONTEND_PODS=$(kubectl get pods -l app=campus-connect-frontend --no-headers | wc -l)
          FRONTEND_READY=$(kubectl get pods -l app=campus-connect-frontend --no-headers | grep "Running" | wc -l)
          
          echo "Backend pods: $BACKEND_READY/$BACKEND_PODS ready"
          echo "Frontend pods: $FRONTEND_READY/$FRONTEND_PODS ready"
          
          if [ "$BACKEND_READY" -eq 0 ] || [ "$FRONTEND_READY" -eq 0 ]; then
            echo "❌ Deployment failed - pods are not running"
            echo "=== Backend pod logs ==="
            kubectl logs -l app=campus-connect-backend --tail=50 || true
            echo "=== Frontend pod logs ==="
            kubectl logs -l app=campus-connect-frontend --tail=50 || true
            exit 1
          fi
          
          echo "✅ All pods are running successfully!"

      - name: Test application endpoints
        run: |
          echo "=== Testing application health ==="
          
          # Get the ingress external IP
          INGRESS_IP=$(kubectl get service -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          if [ -z "$INGRESS_IP" ]; then
            echo "❌ Ingress IP not available yet"
            kubectl get service -n ingress-nginx
            exit 1
          fi
          
          echo "Ingress IP: $INGRESS_IP"
          
          # Test frontend (should return 200)
          echo "Testing frontend..."
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$INGRESS_IP/ || echo "000")
          echo "Frontend status: $FRONTEND_STATUS"
          
          # Test backend health endpoint
          echo "Testing backend health..."
          BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$INGRESS_IP/api/health || echo "000")
          echo "Backend health status: $BACKEND_STATUS"
          
          if [ "$FRONTEND_STATUS" != "200" ] || [ "$BACKEND_STATUS" != "200" ]; then
            echo "❌ Application health checks failed"
            echo "Frontend: $FRONTEND_STATUS, Backend: $BACKEND_STATUS"
            exit 1
          fi
          
          echo "✅ Application health checks passed!"
